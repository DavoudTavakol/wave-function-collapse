\documentclass[12pt]{report}
% Bibliotheken und Pfade
\usepackage{xcolor} %Farben
\usepackage{graphicx} %Bilder
\usepackage{subfig} %Bilder erweiterung
\usepackage{hyperref} %Links
\usepackage{geometry} %margins
\usepackage[utf8]{inputenc} %Standard!
\usepackage{mathptmx} %Wir benutzen hier eine Mathebibiliothen um Times new Roman zu verwenden
\usepackage[T1]{fontenc} %Standard!
\usepackage{setspace} %zeilenabstände
\usepackage{float}
\usepackage{listings} %code darstellung
\usepackage{blindtext} %Blindtext1
\usepackage{lipsum} %blindtext2
%für deutsch
\usepackage[ngerman]{babel}

\usepackage{titlesec} %zum entfernen der "Kapitel N" header

%wir wollen formatieren{was genau?}[optionaler argument: im block satz.]{kapitel nummerierung und font}{der kapitelname mit angehängtem punkt .}{abstand zwischen nummer und name}{größe titel}
\titleformat{\chapter}[block]{\normalfont\Large\bfseries}{\thechapter.}{1em}{\Large}

\titlespacing*{\chapter}{0pt}{40pt}{30pt} % this alters "before" spacing (the second length argument) to 0
%\titlespacing*{\chapter}{0pt}{50pt}{40pt} % default

\graphicspath{ {images/} }
\geometry{top=3.0cm}


\hypersetup{
    colorlinks,
    linkcolor={black!50!black},
    citecolor={blue!50!black},
    urlcolor={blue!80!black}
}


% Baue die Titel Struktur + Inhalt
\title{
{Bachelorarbeit}\\
{\vspace{10mm}}
{\small Wave-Function-Collapse}\\
{\small Funktionsweise und Anwendungsfälle}\\
{\small TH-Nürnberg Georg-Simon-Ohm}\\
}
% Setze Author und Datum
\author{Davoud Tavakol}
\date{29.12.2022}

% Start Dokument
\begin{document}

% Erstelle den Titel (Dieser Befehlt setzt dann auch den Author und das Datum!)
\maketitle

{\let\clearpage\relax\chapter*{Abstract}}

zum schluss..

% Automatisches Inhaltsverzeichniss
\tableofcontents

{\let\clearpage\relax\chapter{Abkürzungsverzeichnis}}

WFC\dotfill{Wave-Function-Collapse}\\
PCG\dotfill{Procedural-Content-Generation}\\
CSP\dotfill{Constraint-Satisfaction-Problem}\\

\chapter{Einleitung}

TODO AM ENDE.
Die automatische Generierung von Inhalten wie Texte, Images oder Modellen ist heutzutage Standard in vielen Bereichen der Industrie.
Um solche Inhalte vordefinierten Parametern zu erstellen werden vor allem zwei Methoden zur Generierung verwendend.
AI's {(Künstliche Intelligenzen)} wie ChatGPT und Algorithmen.
Der logische Vorteil von solchen Tools ist es, das diese in kürzester Zeit qualitative Resultate Generieren können und auch wie oben erwähnt vordefinierte Parameter als Input erhalten können,
um die Ergebnisse für ihren gebrauch anzupassen.
In dieser Bachelorarbeit werde ich mich auf den Wave-Function-Collapse Algorithmus, dessen Funktionsweise und Anwendungsfälle fokussieren.

\chapter{Textursynthesen im Vergleich}

Es gibt viele Möglichkeiten Textursynthese mit Algorithmen zu erzielen.
Die meisten dieser Methoden basieren auf demselben Grundprinzip aus kleineren Input-Images größere oder gleich große Output-Images zu generieren.
Nach D.Gomathi und Rajvi Shah {([8], S.1)}, kann die Textursynthese wie folgt definiert werden.\\\\
Ziel einer Textursynthese ist es aus einer Texturprobe eine neue Textur zu generieren die, "wenn sie von einem menschlichen Beobachter wahrgenommen wird,
durch denselben zugrundeliegenden Prozess erzeugt wird."
Das Ergebnis muss der Texturprobe ähnlich sein aber dennoch in der Wahrnehmung genügend Variation enthalten.
So eine Synthese ist nicht möglich, wenn man die Eingabetextur einfach mehrfach kachelt.
Dadurch erhält man keine "sauberen" Übergänge, und die einzelnen Blöcke sind klar erkennbar. {(siehe Abb. 3.1)}

\begin{figure}[H]
    \centering
    \subfloat[][]{\includegraphics[width=0.4\linewidth]{texture-blocky.JPG}}%
    \qquad
    \subfloat[][]{\includegraphics[width=0.4\linewidth]{texture-correct.JPG}}%
    \caption{(a) Blockartige Textur, (b) Textursynthese}%
\end{figure}

\noindent Dadurch ergeben sich folgende Metriken die erfüllt werden müssen.

\begin{itemize}
    \item Wenn Texturprobe gegeben, generiere eine neue Textur, die der Probe gleicht.
    \item Die neue Textur kann eine beliebige Größe haben die vom Benutzer festgelegt wird.
    \item Es sollen keine sichtbaren Übergänge, Artefakte oder fehlerhafte Kanten sichtbar sein.
    \item Dasselbe Muster soll nicht mehrfach in der neuen Textur vorkommen. {([8], S.2)}
\end{itemize}

\noindent Im Folgenden werde ich auf drei verschiedene Textursynthese verfahren eingehen da diese sich fundamental voneinander unterscheiden.

\section{Pixel basierende Methoden}

Bei dieser Methode werden neue Texturen Pixel für Pixel generiert.
Jeder neue Pixelwert wird von seinen lokalen Nachbarn festgelegt.
Dieser verfahren verwenden meistens Markow-Netzwerke \textit{(Markov-Random-Fields)} die relativ gute Resultate liefern mit wenig Rechenlast.
Markov-Random-Fields Methoden beurteilen jeden Pixel nach einer kleinen Menge von Nachbarn.
Voraussetzung hierfür ist, dass das Input-Image stationär und lokal ist.
Ein Image wird als stationär bezeichnet wenn, unter korrekter Fenstergröße,
jeder betrachtete Bereich ähnlich zueinander aussehen.
Lokal ist ein Image dann, wenn jeder Pixel allein von seinen Nachbarn bestimmt werden kann.{[8]}

\begin{figure}[H]
    \centering
    \subfloat[][]{\includegraphics[width=0.4\linewidth]{Textur-nicht-stationärlokal.JPG}}%
    \qquad
    \subfloat[][]{\includegraphics[width=0.4\linewidth]{Textur-stationärlokal.JPG}}%
    \caption{(a) Nicht stationär und lokal, (b) stationär und lokal}%
\end{figure}

\noindent Unterschiedliche Bereiche einer Textur sehen sich immer ähnlich {(siehe Abb. 3.2 (b))}.
Dies ist nicht der Fall für normale Images wie wir bei Abb. 3.2 {(a)} erkennen können.
Zudem ist es möglich jeden Pixel in {(b)} allein durch seine benachbarten Pixel zu bestimmen.
Diese Attribute bezeichnet man als Stationär und Lokal.{[8]} \\

%TODO


\noindent Wichtig hierbei ist, dass das Muster des Output-Images lokal ähnlich oder gleich ist.
Das wird größtenteils dadurch erzielt das aus dem Input-Image kleinere Subimages extrahiert werden {(z.B. 5 x 5 Pixel Fenster)}.
Bei den verfahren, wo die lokale Ähnlichkeit nicht 1-zu-1 bzw. pixelgenau stattfindet, werden die Pixel und deren Farbwert oft nach Grundlage der Abstandsmetrik {(z.B. dem euklidischen Abstand von Pixelfarbvektoren)} beurteilt.
Solche Verfahren finden meistens in der rein visuellen Computergrafik Anwendung.
Diese Methodiken haben große Nachteile im Gegensatz zu Algorithmen wo das lokale Muster des Outputs pixelgenau dem Input-Image gleicht.
Gerade bei PCG {(Procedural-Content-Generation)} kann die Pixelgenauigkeit von großen Nutzen sein da dadurch Abgrenzungen der Pixel innerhalb des Output-Images klar definiert sein können.
{[1]}
Der WFC von Gumin ist lose an der Quantenmechanik angelehnt.
Das liegt daran, dass bei der Synthese von WFC in jeder Zelle des $N\times N$ Output-Images theoretisch jedes Muster / Pixelwert vorkommen kann bevor sie final festgelegt werden.
Dieser Zustand nennt sich \textit{Superposition}.
Jede Zelle hat mehrere Eigenwerte \textit{(eigenstates)} und somit auch eine maximale Entropie bzw. einen maximalen Informationsgehalt.
Sobald eine Zelle bekannt wird \textit{(Observation)} und damit nur einen Eigenwert besitzt, dann wird die Entropie aller anderen Zellen angepasst.
{(Auf dieses Verhalten wird später tiefer eingegangen)}. {[2]}
Gumin hat sich von der Arbeit von Paul Merell Inspirieren lassen, obwohl dieser sich Hauptsächlich mit der Generierung von 3D-Modellen befasst hatte.
Bei seinem Verfahren werden die Modelle mithilfe von bereits erstellten Bausteinen zusammengesetzt.
Das ist dahingehen wichtig da in vielen Textursynthesen gerade bei den Übergängen die Pixel sich Mischen und somit sich Artefakte bilden.
Dieser Verhalten ist bei WFC und dem Verfahren von Paul Merell nicht möglich da es sich um eine diskrete Synthese handelt.
Jedes lokale Muster ist immer im Input wiederzufinden. {[1]}{[3]}{[4]}

\section{Constraint-Satisfaction-Problem}

Was ist ein Constraint-Satisfaction-Problem? {(CSP)}
Grundsätzlich beschreiben CSP's Gruppen von Objekten denen Variablen zugeteilt sind.
Diesen Variablen sind Regeln, sogenannte \textit{(constraints)}, auferlegt die erfüllt werden müssen.
Jeder dieser Variablen hat zu Beginn eine Superposition und kann damit jeden wert enthalten.
Die Aufgabe von Algorithmen zum Lösen von CSP's \textit{(solver)} ist es einen Zustand \textit{(State)} zu finden in denen alle constraints erfüllt sind und jeder Variable nur noch ein wert zugeordnet ist.
Für solche Probleme finden sich oft bei der Künstlichen Intelligenz und aus dem Operations Research. {[5]}
Im Fall von WFC sind die Objekte, denen die Variablen zugeteilt sind, die einzelnen Bereiche im Output-Image.
Jeder diese Bereiche muss ein lokales Muster aus dem Input zugeordnet werden.
Immer, wenn einem Bereich ein wert zugeordnet wird, dann werden auch die benachbarten Bereiche damit beeinflusst \textit{(Propagation)}.
Der Gesamtprozess, wenn sich eine Gruppe aus Superpositionen mit mehreren Eigenwerten zu einem einzelnen Eigenwert aufgrund von Interaktion mit der Außenwelt \textit{(Observation)} reduziert,
nennt sich Wave-Function-Collapse. {[6]}
Während dem Prozess einen gültigen State für das CSP zu finden, dann gibt es immer Situationen in dem es mehrere gültige Optionen für eine Variable gibt.
Wenn so eine Situation auftritt, dann haben verschiedene Solver verschiedene Ansätze.
Einige Algorithmen wähle zufällig eine der möglichen Werte von momentan zulässigen Optionen.
Bei so einem Ansatz kann es sein das der Algorithmus nicht auf einen Zustand kommen kann, in dem alle constraints erfüllt werden können.
In so einem Fall gibt es Rücksetzverfahren \textit{(Backtracking)} bei dem der Algorithmus zu seinem letzten Ergebnis zurückfällt und ein anderen Wert für die Variable setzt, um aus dem
ungültigen Zustand zu kommen.
Andere Algorithmen verwenden zusätzliche Heuristiken abgesehen von den bereits bekannten constraints, um die Möglichkeit eines ungültigen Zustandes zu reduzieren. {[1]} 

\section{Wave-Function-Collapse in Game Development}

In Abschnitt 4.1 wurde bereits auf mögliche Vorteile einer pixelgenauen Textursynthese hingewiesen.
Der große Vorteil einer solchen Synthese ist, das dadurch der generierte Content auch Interaktiv genutzt werden kann, da wir vollen Kontrolle über die lokalen Muster des Outputs haben.
Dadurch bietet sich WFC gerade für die Spiele-Entwicklung an, da keine unvorhersehbaren Artefakte entstehen können.
Viele PCG Methoden Garantieren häufig Ergebnisse, wobei die Kosten für diese Garantie in Form einer unvorhersehbaren Gesamtlaufzeit einhergeht.
Diese Backtracking Löser liefern bei ihren Aufgaben für die Lösung Ihrer CSP's oft gute Leistungen, wobei diese Ergebnisse in Theorie aber nur schwer zu charakterisieren sind.
Eine "schnelle" Methode von Horswill und Foged [7] um eine spielbares Leveldesign zu generieren ist der {(AC3)} Algorithmus.
Dieser Algorithmus basierend auf Backtrackingsearch mit Constraint Propagation stellt zwar geringe Anforderungen an Prozessor- und Speicherressourcen,
allerdings wird erwartet, dass er von Programmierern verwendet werden die sich wenigstens mäßig mit Suchalgorithmen und Design auskennen.
Bereits ein Tag nach der Veröffentlichung von Gumin's WFC am 30. September 2016 haben viele Entwickler bereits begonnen mit diesem Algorithmus zu experimentieren.
Grund für die große Beliebtheit dafür ist nicht nur die bereits erwähnten Pixelgenauigkeit, sondern auch die live Generierung des Outputs selbst. {[1]}

%Erklärung warum WFC overlappig so gut aussieht
Viele PCG's Methoden variieren in ihrer Laufzeit bei der Generierung ihres Outputs.
Dies führt dazu das manchmal bereits Großteile des Outputs sofort generiert werden dafür aber der Abschluss aufgrund von komplexen constraint solving Algorithmen nicht gleichmäßig entsteht. {[1]}



{\let\clearpage\relax\chapter{Begriffserklärung}}

{\let\clearpage\relax\chapter{Theorie}}
{\let\clearpage\relax\chapter{Stand der Forschung}}
{\let\clearpage\relax\chapter{Ergebnisse}}
{\let\clearpage\relax\chapter{Diskussion der Ergebnisse}}

{\let\clearpage\relax\chapter{Fazit}}

{\let\clearpage\relax\chapter{Literaturverzeichnis}}
{[1]} \url{https://adamsmith.as/papers/wfc_is_constraint_solving_in_the_wild.pdf}\\
{[2]} \url{https://en.wikipedia.org/wiki/Wave_function_collapse}\\
{[3]} \url{https://paulmerrell.org/wp-content/uploads/2021/06/thesis.pdf}\\
{[4]} \url{https://github.com/mxgmn/WaveFunctionCollapse}\\
{[5]} \url{https://en.wikipedia.org/wiki/Constraint_satisfaction_problem}\\
{[6]} \url{https://en.wikipedia.org/wiki/Wave_function_collapse}\\
{[7]} \url{https://ojs.aaai.org/index.php/AIIDE/article/view/12511/12364}\\
{[8]} \url{http://rajvishah.weebly.com/uploads/6/3/0/9/6309814/texture_synthesis_final_report.pdf}\\
\url{https://www.cv-foundation.org/openaccess/content_cvpr_2016/papers/Gatys_Image_Style_Transfer_CVPR_2016_paper.pdf}\\
\url{https://www.th-nuernberg.de/fileadmin/global/Gelenkte_Doks/Fak/SW/SW_0600_HR_Leitfaden_WA_public.pdf}\\
\url{https://www.ghost-writing.net/wissenschaftliche-arbeit-auf-englisch-verfassen/}\\
\url{https://www.youtube.com/watch?v=rI_y2GAlQFM&t=1135s&ab_channel=TheCodingTrain}\\
\url{https://users.informatik.haw-hamburg.de/~abo781/abschlussarbeiten/ba_westfalen.pdf}\\
\url{https://users.informatik.haw-hamburg.de/~abo781/abschlussarbeiten/ba_dzaebel.pdf}\\
\url{http://people.csail.mit.edu/celiu/Patch-based%20Texture%20Synthesis/Index.htm}\\
\url{https://www2.eecs.berkeley.edu/Research/Projects/CS/vision/papers/efros-iccv99.pdf}\\


{\let\clearpage\relax\chapter{Anhang}}
{\let\clearpage\relax\chapter{Eidesstattliche Erklärung}}
\end{document}